package club.eridani.cursa.module.modules.exploit;

import club.eridani.cursa.common.annotations.Module;
import club.eridani.cursa.module.Category;
import club.eridani.cursa.module.ModuleBase;
import club.eridani.cursa.notification.NotificationManager;
import club.eridani.cursa.setting.Setting;
import club.eridani.cursa.utils.BlockInteractionHelper;
import club.eridani.cursa.utils.BlockUtil;
import club.eridani.cursa.utils.EntityUtil;
import club.eridani.cursa.utils.InventoryUtil;
import net.minecraft.block.BlockAir;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketAnimation;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

@Module(name = "TrapPhase" , category = Category.EXPLOIT)
public class TrapPhase extends ModuleBase {
    public Setting<Float> offset = setting("Offset" , 0.2F , 0.6F , 0.1F);
    public Setting<Boolean> packetPlace = setting("PacketPlace" , true);

    public void onTick() {
        int slot = InventoryUtil.getBlockHotbar(Blocks.IRON_TRAPDOOR);
        if(slot == -1) {
            NotificationManager.error("Cannot find trapdoor! disabling");
            disable();
            return;
        }
        BlockPos playerPos = EntityUtil.getEntityPos(mc.player);
        BlockPos trappos = null;
        BlockPos[] offsets = new BlockPos[]{
                new BlockPos(1 , 0 , 0) ,
                new BlockPos(-1 , 0 , 0) ,
                new BlockPos(0 , 0 ,1) ,
                new BlockPos(0 , 0 , -1)
        };
        for(BlockPos offset : offsets){
            BlockPos pos = playerPos.add(offset);
            if(BlockUtil.getBlock(pos) instanceof BlockAir) continue;
            trappos = pos;
        }
        if(trappos == null) {
            NotificationManager.error("Cannot find space! disabling");
            disable();
            return;
        }

        double x = mc.player.posX;
        double y = mc.player.posY;
        double z = mc.player.posZ;
        mc.player.connection.sendPacket(new CPacketPlayer.Position(x , y + this.offset.getValue() , z , mc.player.onGround));
        EnumFacing facing = null;
        for(EnumFacing f : EnumFacing.values()) if(trappos.add(f.getDirectionVec()).equals(playerPos)) facing = f;
        mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
        BlockInteractionHelper.rightClickBlock(trappos , facing , new Vec3d(0.5 , 0.8 , 0.5) , packetPlace.getValue());
        mc.player.connection.sendPacket(new CPacketHeldItemChange(mc.player.inventory.currentItem));
        mc.player.connection.sendPacket(new CPacketPlayer.Position(x , y , z , mc.player.onGround));
        disable();
    }
}
